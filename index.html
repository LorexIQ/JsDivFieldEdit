<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Title</title>

  <link rel="stylesheet" href="fonts/fontAwesome/css/font-awesome.min.css">
</head>

<style lang="scss">
  :root {
    --main-grid-max-size: 3040px;
    --main-grid-min-size: 500px;
    --main-grid-scale: 1;
  }

  @keyframes errorAddCircle {
    from {
      fill: #868686;
    }
    50% {
      fill: #ff3b6b;
    }
    to {
      fill: #868686;
    }
  }
  @keyframes errorAddDiv {
    from {
      transform: scale(1);
    }
    50% {
      transform: scale(1.1);
    }
    to {
      transform: scale(1);
    }
  }

  .error-add {
    animation-name: errorAddDiv;
    animation-duration: 0.3s;
  }
  .error-add>svg>circle {
    animation-name: errorAddCircle;
    animation-duration: 0.3s;
  }

  @keyframes successAddCircle {
    from {
      fill: #868686;
    }
    50% {
      fill: #2ab99d;
    }
    to {
      fill: #868686;
    }
  }
  @keyframes successAddDiv {
    from {
      transform: scale(1);
    }
    50% {
      transform: scale(1.1);
    }
    to {
      transform: scale(1);
    }
  }

  .success-add {
    animation-name: successAddDiv;
    animation-duration: 0.3s;
  }
  .success-add>svg>circle {
    animation-name: successAddCircle;
    animation-duration: 0.3s;
  }

  body, html {
    height: 100%;
    margin: 0;

    background-color: #ffffff;
  }

  #field {
    width: 500px;
    height: 500px;

    overflow: hidden;
    position: relative;
  }

  .block-btn {
    display: flex;
    flex-direction: column;
  }

  #points {
    position: absolute;
    left: 10px;
    top: 10px;
  }

  .zoom {
    position: absolute;
    right: 10px;
    top: calc(50% - 70px);
  }

  .center {
    position: absolute;
    right: 10px;
    bottom: 10px;
  }

  .add-check {
    z-index: 1001;
  }
  .custom-checkbox {
    position: absolute;
    z-index: -1;
    opacity: 0;
  }
  .custom-checkbox+label {
    cursor: pointer;
    display: inline-flex;
    align-items: center;
    user-select: none;
  }
  .custom-checkbox+label::before {
    font-family: 'FontAwesome',serif;
    color: #fff;
    background-color: #bbb;
    box-shadow: 0 0 12px 2px #bababa;

    width: 40px;
    height: 40px;
    margin-bottom: 10px;
    flex-shrink: 0;
    flex-grow: 0;
    border: 0;
    border-radius: 10px;

    display: flex;
    justify-content: center;
    align-items: center;

    transition: 0.3s;
  }
  .custom-checkbox:checked+label::before {
    background-color: #868686;
    transform: scale(0.95);
  }

  #add+label::before {
    content: '\f041';
  }

  #del+label::before {
    content: '\f00d';
  }

  .fieldPoint {
    transition: .3s;
  }
  
  .btn {
    width: 40px;
    height: 40px;

    background-color: #bababa;
    border: 0;
    border-radius: 10px;
    margin: 0 0 10px 0;

    transition: 0.3s;

    box-shadow: 0 0 12px 2px #bababa;
  }

  .btn:last-child {
    margin: 0;
  }

  .btn:hover {
    background-color: #868686;
  }

  .btn:active {
    background-color: #666;
    transform: scale(0.95);
  }

  .btn>p {
    margin: 0;
    font-size: 18px;
    color: #fff;
  }

  .point {
    position: absolute;
    z-index: 1000;
    visibility: hidden;
    cursor: none;
    width: 20px;
    height: 20px;
    display: flex;
    justify-content: center;
    align-items: center;
  }

  .point>svg {
    border-radius: 100%;
    box-shadow: 0 0 10px 2px #bbb;
  }

  #gridField {
    width: var(--main-grid-max-size);
    height: var(--main-grid-max-size);

    background: 0 calc(var(--main-grid-max-size) / 2) url("data:image/svg+xml,%3Csvg width='40' height='2' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath d='M 40,0 L 0,0' fill='transparent' stroke='%23989898'/%3E%3C/svg%3E") repeat-x,
    calc(var(--main-grid-max-size) / 2) 0 url("data:image/svg+xml,%3Csvg width='2' height='40' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath d='M 0,40 L 0,0' fill='transparent' stroke='%23989898'/%3E%3C/svg%3E") repeat-y,
    url("data:image/svg+xml,%3Csvg version='1.1' baseProfile='full' width='40' height='40' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath d='M 0,40 L 0,0 40,0' fill='transparent' stroke='%23e3e4e6'/%3E%3C/svg%3E"),
    #f8faff;

    position: absolute;
    transform: scale(var(--main-grid-scale));
    transform-origin: left top;
  }
</style>

<body>
<div id="field">
  <div id="point-add" style="left: 20px; top: 20px;" class="point" onclick="addPointInField()">
    <svg width="20" height="20"
         xmlns="http://www.w3.org/2000/svg">
      <circle cx="10" cy="10" r="10" fill="#868686" id="pointer-adder" />
    </svg>
  </div>
  <div draggable="true" id="gridField">
    <svg xmlns="http://www.w3.org/2000/svg" id="content">

    </svg>
  </div>
  <div id="points" class="block-btn">
    <div class="add-check">
      <input type="checkbox" id="add" class="custom-checkbox" onchange="addPoint()">
      <label for="add"></label>
    </div>
    <div class="add-check">
      <input type="checkbox" id="del" class="custom-checkbox" onchange="delPoint()">
      <label for="del"></label>
    </div>
  </div>
  <div class="block-btn zoom">
    <button onclick="zoomUp()" class="btn">
      <p class="fa fa-plus"></p>
    </button>
    <button onclick="reloadZoom()" class="btn">
      <p>1:1</p>
    </button>
    <button onclick="zoomDown()" class="btn">
      <p class="fa fa-minus"></p>
    </button>
  </div>
  <div class="block-btn center">
    <button onclick="centred()" class="btn">
      <p class="fa fa-crosshairs"></p>
    </button>
  </div>
</div>
<div class="navigate">
  <a href="#" class="custom-btn" onclick="traceButton()">Трасировка</a>
</div>
</body>

<script>
  let scaleValue = 1;
  const maxScale = 3;
  const maxSize = 3040;
  const minSize = 500;
  let added = false;
  let deleted = false;
  let drag = true;
  let arrayPoints = []
  let currentId = 0;

  class Line {
    constructor(point_a, point_b) {
      this.point_a = point_a;
      this.point_b = point_b;
      this._len = ((point_a.x - point_b.x) ** 2 + (point_a.y - point_b.y) ** 2) ** 0.5;
    }
    get len() {
      return this._len;
    }
  }

  class MinTree {
    constructor(points) {
      this.points = points;
      this.lines = [];
    }
    sliceLines() {
      for (let i = 0; i < this.lines.length; i++) {
        for (let j = 0; j < this.lines.length; j++) {
          if (intercept(this.lines[i], this.lines[j])) {
            this.lines.splice(j, 1);
            return true;
          }
        }
      }
      return false;
    }
    trace() {
      for (let i = 0; i < this.points.length - 1; i++) {
        for (let j = i + 1; j < this.points.length; j++) {
          this.lines.push(new Line(this.points[i], this.points[j]));
        }
      }
      while (this.sliceLines()) {
        this.lines.sort(() => Math.random() - 0.5);
      }
      // for (let i = 0; i < this.lines.length; i++) {
      //   for (let j = 0; j < this.lines.length; j++) {
      //     if (intercept(this.lines[i], this.lines[j])) {
      //       this.lines.splice(j, 1);
      //       j--;
      //     }
      //   }
      // }
      for (let line of this.lines) {
        content.insertAdjacentHTML('afterbegin', `<path class="line" d='M${line.point_a.x} ${line.point_a.y} L${line.point_b.x} ${line.point_b.y} Z' stroke='#868686' stroke-width='3'/>`);
      }
    }
  }

  centred();
  clearTools();

  let content = document.getElementById('content');
  content.style.width = maxSize + 'px';
  content.style.height = maxSize + 'px';

  let tasksListElement = document.getElementById('gridField');
  let pointer = document.getElementById('point-add');
  tasksListElement.onmousedown = function (event) {
    if (drag) {
      unActiveAllPoints();
      const pos_div = tasksListElement.getBoundingClientRect();
      const first_pos = {
        x: event.clientX,
        y: event.clientY
      };
      function onMouseMove (event_move) {
        const deviation_value = {
          width: event_move.clientX - first_pos.x,
          height: event_move.clientY - first_pos.y
        };
        tasksListElement.style.left = pos_div.x + deviation_value.width + 'px';
        tasksListElement.style.top = pos_div.y + deviation_value.height + 'px';

        fixedPosition();
      }
      document.addEventListener('mousemove', onMouseMove);
      tasksListElement.onmouseout = function() {
        document.removeEventListener('mousemove', onMouseMove);
        tasksListElement.onmouseup = null;
      };
      tasksListElement.onmouseup = function() {
        document.removeEventListener('mousemove', onMouseMove);
        tasksListElement.onmouseup = null;
      };
    }
  }
  tasksListElement.ondragstart = function () {
    return false;
  }
  tasksListElement.onmousemove = function (event) {
    if (added) {
      movePointer(event);
    }
  }
  pointer.onmousemove = function (event) {
    movePointer(event)
  }
  document.getElementById('points').onmousemove = function (event) {
    if (added) {
      movePointer(event);
    }
  }

  function traceButton () {
    clearTools();
    clearLines();
    let test = new MinTree(arrayPoints);
    test.trace();
  }

  function addPointInField () {
    const rectPointer = pointer.getBoundingClientRect();
    const rectField = tasksListElement.getBoundingClientRect();
    const coords = {
      x: (rectPointer.x + 10 - rectField.x) / scaleValue,
      y: (rectPointer.y + 10 - rectField.y) / scaleValue
    }
    if (arrayPoints.length !== 0) {
      for (let point of arrayPoints) {
        if (Math.abs(point.x - coords.x) < 30 && Math.abs(point.y - coords.y) < 30) {
          pointer.classList.add('error-add');
          setTimeout(() => {
            pointer.classList.remove('error-add');
          }, 300);
          return;
        }
      }
    }
    pointer.classList.add('success-add');
    setTimeout(() => {
      pointer.classList.remove('success-add');
    }, 300);
    content.insertAdjacentHTML('beforeend', `<circle cx="${coords.x}" cy="${coords.y}" r="10" fill="#868686" class="fieldPoint" style="transition: 0.3s" id="point-${currentId}" onclick="selectPoint(${currentId}); delPointFromField(${currentId})" onmouseover="blockDrag(true)" onmouseout="blockDrag(false)"/>"`);
    arrayPoints.push({
      id: currentId,
      x: coords.x,
      y: coords.y
    });
    currentId += 1;
  }
  function delPointFromField (id) {
    if (deleted) {
      let point = document.getElementById(`point-${id}`);
      setTimeout(() => {
        point.remove();
      }, 300);
      const pointPosition = {
        x: point.cx.animVal.value,
        y: point.cy.animVal.value
      }
      point.style.r = '0';
      const objArray = arrayPoints.filter(res => res.x === pointPosition.x && res.y === pointPosition.y)[0];
      arrayPoints.splice(arrayPoints.indexOf(objArray), 1);
    }
  }
  function unActiveAllPoints () {
    for (let point of document.querySelectorAll('.fieldPoint')) {
      point.style.fill = "#868686";
    }
  }
  function blockDrag (mode) {
    drag = !mode;
  }
  function selectPoint (id) {
    if (!deleted) {
      unActiveAllPoints();
      let point = document.getElementById(`point-${id}`);
      point.style.fill = "#ff3b6b";
    }
  }
  function movePointer (event) {
    if (added) {
      const coords = {
        x: event.clientX,
        y: event.clientY
      }

      pointer.style.left = coords.x - 10 + 'px';
      pointer.style.top = coords.y - 10 + 'px';
    }
  }
  function clearTools () {
    if (added) {
      pointer.style.visibility = "hidden";
      added = false;
    }

    deleted = false;
    for (let check of document.querySelectorAll('.custom-checkbox')) {
      check.checked = false;
    }
  }
  function clearLines () {
    for (let line of document.querySelectorAll('.line')) {
      line.remove();
    }
  }
  function addPoint () {
    if (deleted) {
      document.getElementById('del').checked = false;
      delPoint();
    }
    clearLines();
    unActiveAllPoints();
    added = document.getElementById('add').checked;
    if (added) {
      pointer.style.visibility = "visible";
    } else {
      pointer.style.visibility = "hidden";
    }
  }
  function delPoint () {
    if (added) {
      document.getElementById('add').checked = false;
      addPoint();
    }
    clearLines();
    unActiveAllPoints();
    deleted = document.getElementById('del').checked;
  }
  function intercept(line_1, line_2) {
    const x1 = line_1.point_a.x;
    const y1 = line_1.point_a.y;
    const x2 = line_1.point_b.x;
    const y2 = line_1.point_b.y;
    const x3 = line_2.point_a.x;
    const y3 = line_2.point_a.y;
    const x4 = line_2.point_b.x;
    const y4 = line_2.point_b.y;
    if (JSON.stringify(line_1.point_a) === JSON.stringify(line_2.point_a) ||
            JSON.stringify(line_1.point_a) === JSON.stringify(line_2.point_b) ||
            JSON.stringify(line_1.point_b) === JSON.stringify(line_2.point_a) ||
            JSON.stringify(line_1.point_b) === JSON.stringify(line_2.point_b)) {
      return false;
    }
    let Ua, Ub, num_a, num_b, den;
    den = (y4 - y3) * (x1 - x2) - (x4 - x3) * (y1 - y2);
    if (den === 0) {
      return (x1 * y2 - x2 * y1) * (x4 - x3) - (x3 * y4 - x4 * y3) * (x2 - x1) === 0 &&
              (x1 * y2 - x2 * y1) * (y4 - y3) - (x3 * y4 - x4 * y3) * (y2 - y1) === 0;
    }
    else {
      num_a = (x4 - x2) * (y4 - y3) - (x4 - x3) * (y4 - y2);
      num_b = (x1 - x2) * (y4 - y2) - (x4 - x2) * (y1 - y2);
      Ua = num_a / den;
      Ub = num_b / den;
      return Ua > 0 && Ua < 1 && Ub > 0 && Ub < 1;
    }
  }
  function lineSegmentsIntersect (line_1, line_2) {
    const x1 = line_1.point_a.x;
    const y1 = line_1.point_a.y;
    const x2 = line_1.point_b.x;
    const y2 = line_1.point_b.y;
    const x3 = line_2.point_a.x;
    const y3 = line_2.point_a.y;
    const x4 = line_2.point_b.x;
    const y4 = line_2.point_b.y;
    let det, gamma, lambda;
    det = (x2 - x1) * (y4 - y3) - (x4 - x3) * (y2 - y1);
    if (det === 0) {
      return false;
    } else {
      lambda = ((y4 - y3) * (x4 - x1) + (x3 - x4) * (y4 - y1)) / det;
      gamma = ((y1 - y2) * (x4 - x1) + (x2 - x1) * (y4 - y1)) / det;
      return (0 < lambda && lambda < 1) && (0 < gamma && gamma < 1);
    }
  }
  function setScale (value = 1, editor = 0) {
    scaleValue = value + editor
    document.documentElement.style.setProperty('--main-grid-scale', '' + scaleValue);
  }
  function updateScale () {
    scaleValue = parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--main-grid-scale'));
  }
  function reloadZoom () {
    setScale ();
    centred ();
  }
  function zoomUp () {
    updateScale ();
    if (scaleValue + 0.1 > maxScale) return;

    const oldRect = tasksListElement.getBoundingClientRect();

    setScale(scaleValue, 0.1);

    const newRect = tasksListElement.getBoundingClientRect();
    tasksListElement.style.left = newRect.x - (newRect.width - oldRect.width) / 2 + 'px';
    tasksListElement.style.top = newRect.y - (newRect.width - oldRect.width) / 2 + 'px';
  }
  function zoomDown () {
    updateScale ();
    if ((scaleValue - 0.1) * maxSize < minSize) return;

    const oldRect = tasksListElement.getBoundingClientRect();

    setScale(scaleValue, -0.1);

    const newRect = tasksListElement.getBoundingClientRect();
    tasksListElement.style.left = newRect.x - (newRect.width - oldRect.width) / 2 + 'px';
    tasksListElement.style.top = newRect.y - (newRect.width - oldRect.width) / 2 + 'px';

    fixedPosition();
  }
  function centred () {
    updateScale ()
    let grid_elem = document.getElementById('gridField');
    grid_elem.style.left = -(maxSize * scaleValue - minSize) / 2 + 'px';
    grid_elem.style.top = -(maxSize * scaleValue - minSize) / 2 + 'px';
  }
  function fixedPosition () {
    let grid_elem = document.getElementById('gridField');
    let pos_div = grid_elem.getBoundingClientRect();

    if (pos_div.right < minSize)
      grid_elem.style.left = pos_div.x + (minSize - pos_div.right) + 'px';
    if (pos_div.bottom < minSize)
      grid_elem.style.top = pos_div.y + (minSize - pos_div.bottom) + 'px';
    if (pos_div.x > 0)
      grid_elem.style.left = '0px';
    if (pos_div.y > 0)
      grid_elem.style.top = '0px';
  }
</script>
</html>
